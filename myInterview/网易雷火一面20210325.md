# 网易游戏雷火事业群-前端暑期实习一面 20210325

> 岗位：前端开发工程师（媒体中心）岗位
> 类型：暑期实习
> 面试时间：2021-03-25 14 : 40
> 面试时长：大约 35 分钟

春招第一次进入面试，那是因为……雷火这边是直接不用笔试进面试😭
面试体验还不错，面我的面试官来得很准时，人也还不错，面试经验 +1。
虽然问的问题都很基础，从 CSS 到 JS 再到 Vue，但是我还有很多不会的，磕磕巴巴的，继续努力吧。

## **面试复盘：**

1. 自我介绍（语速太慢，还需完善）
	自我介绍需要熟悉，要能流利说出来。
	
2. 面试官说：你确定你是面试前端的是吧？（可能看我实习项目跟前端无关吧）

3. CSS3 **盒模型**有哪些？
	

	
4. 那么怎么去设置这个盒模型呢？

  ```
  css盒子属性box-sizing，控制元素盒模型的解析模式。box-sizing: 
  （1）content-box（默认W3C标准盒模型）：盒子大小=width(content)+padding+border。
  （2）padding-box：盒子大小= width(content+padding)+border。
  （3）border-box(IE传统盒模型，IE8以下怪异模式)：盒子大小= width(content+padding+border)
  ```

  

5. 说一下**定位**？



1. 定位层级的关系？**z-index** 具体是怎么比较的？



1. z-index 值越大就在上面吗？例：两个子 div 都有各自的父 div，层级关系是怎么样的？



1. 遇到 **CSS 兼容性问题**你怎么去处理？在你的项目里用到吗？例：不同浏览器上有些属性是没有的，怎么处理？



1. **CSS3 的新特性**有哪些？



1. 如果页面有比较多的**动画**，怎么让它保持流畅（60 FPS ）的效果？动画太多会造成页面卡顿，**优化方案**？



1. **BFC** 你有了解过吗？触发情况？

   ```
   BFC就是一个css的一个布局概念，是一个独立的区域，是一个环境。
   满足下列条件之一就可触发BFC：
   （1）根元素，即html元素。
   （2）float的值不为none的浮动元素。
   （3）position的值为absolute或者fixed的定位元素。
   （4）display的值为inline-block、伸缩盒的元素（inline-flex、flex）、table-caption（相当于caption元素）、table-cell（相当于td，th元素）。
   （5）overflow的值不为visible。
   用途：
   （1）清除浮动：在父元素上设置overflow: hidden样式；
   （2）解决外边距合并问题：盒子垂直方向的距离由margin决定，属于同一个BFC的两个相邻盒子的margin会发生重叠。
   （3）左边固定右边自适应的两栏布局。
   ```

2. **弹性布局**？项目里有用到过吗？

3. 有关自己的项目，深度学习的一些东西有打包到web上吗？**WebAssembly** 相关接触过吗？

4. 项目有关视频流相关，问是否了解过网页上实时传播**视频流**有什么方式？了解过 **WebRTC** 吗？

5. 知道前端方面怎么进行 **GPU 优化**吗？

6. 简单描述一下**变量提升**？函数声明式，函数表达式会提升吗？提升的是什么？

   

7. **继承**的方式？原型链继承大概的实现方式？

   ```javascript
   /*JS中的四大继承方案：继承就是子类继承父类中的属性和方法。
   方案一：原型继承：子类的原型指向父类的一个实例，继承原型上的内容。
   缺点：因为改变原型指向实现继承的同时，初始化了属性，则继承过来的属性一样。并且会丢失原本的原型对象，包括子类constroctor，需要加一个Student.prototyper.constroctor = Student。Student.prototype = new People()会在子类原型对象上有父类的无用属性，则可以使用ES5方法Object.create()，Student.prototype = Object.create(People.prototype)
   优点：可解决方法继承。
   方案二：借用构造函数继承：在子类构造函数中借用父类构造函数，其执行的时候，方法中的this为子类实例。
   缺点：父级类别的方法不能继承。
   优点：可解决属性继承，并且值不重复。
   方案三：组合继承：call继承+原型继承。
   方案四：ES6中class类，extends继承和组合继承基本类似，在子类的constructor中须加上super()函数，相当于A.call(this)。*/
   class People{
       constructor(name){//constructor内定义的方法和属性是实例对象自己的
           this.name = name
       }
       eat(){//constructor外定义的方法和属性是所有实例对象共享的
           console.log(`${this.name} eat something`)    
       }
   }
   class Student extends People{
       constructor(name, number){
           super(name)//在this之前一定要调用super()
           this.number = number
       }
       sayHi(){
           console.log(
               `姓名${this.name}，学号${this.number}`
           )
       }
   }
   
   ```

   

8. **深拷贝**具体是怎么实现的？应用场景是什么？

   ```javascript
   /*浅拷贝和深拷贝都只针对于引用数据类型。
   浅拷贝只复制指向某个对象第一层属性值的指针，而不复制对象本身，新旧对象还是共享同一块内存；
   但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改变原对象；
   区别：浅拷贝只复制对象的第一层属性、深拷贝可以对对象的属性进行递归复制。*/
   // 浅拷贝：把对象第一层属性或方法复制到另一个对象中。
   // 法一：
   function extend(a,b) {
         for(var key in a){
           b[key]=a[key]  }  }
   // 法二：Object.assign()实现浅拷贝或者说一层的深拷贝：
   let obj2 = Object.assign({},obj1)
   // 深拷贝：在另一个对象中开辟空间，把对象中所有的属性或方法，进行递归复制。
   // 法一：
   function extend(obj1, obj2){
       for(let key in obj1){
           let item = obj1[key]
           if(item instanceof Array){     //不能用typeof item这不能分辨出Array、Object
               obj2[key] = []
               extend(item, obj2[key])
           }else if(item instanceof Object){
               obj2[key] = {}
               extend(item, obj2[key])
           }else{
               obj2[key] = item
           }
       }
   }
   // 法二：使用JSON.stringify()（把对象转成字符串），再JSON.parse()（把字符串转成新的对象）
   ```

   

9. **事件循环**，宏任务，微任务？

   ```
   主线程执行的时候，遇到异步任务，会将异步任务放在事件队列中。遇到同步任务会将其放入到主线程中执行。当主线程执行完毕后，会执行事件队列中异步任务。
   
   js单线程原因：防止DOM树修改冲突。JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？
   
   宏任务与微任务：
   （1）宏任务：setTimeout, setInterval, requestAnimation, I/O,一些浏览器API
   （2）微任务：prosess.nextTick，Promise，Object.observe，MutationObserver，JS自身API，或者node
   （3）先微任务后宏任务，先取出第一个宏任务，执行完所有相关微任务，在下一个宏任务之前全部执行完。
   
   ```

   

10. **Promise** 为什么会出现？作用、应用场景是什么？**Async**，**Await**，用过吗？需要等待多个请求回来再进行操作，怎么用 Promise 或者 async，await 实现？

    ```
    Promise模式 ：解决异步问题而产生的，提供了异步编程的解决方式。
    
    当XHR对象发起多个异步请求时，无法保证响应能按发起的顺序返回。如果要保证响应顺序，只能用回调函数的方式控制。这样就会有地狱回调的问题。
    
    Promise是ES6一种异步编程解决方案，通常来表示一个异步操作的成功或失败，是一种代码组织模式，将异步操作用同步操作方式表达，解决了JavaScript地狱回调的问题。
    
    Promise.prototype.then()说明Promise实例具有then()，为Promise实例添加状态改变时的回调函数。then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。
    
    Promise.prototype.catch()方法用于指定发生错误时的回调函数。如果前面有任何的 Promise执行失败，则立即终止所有promise的执行，并马上进入 catch去处理 Promise中抛出的异常。
    
    Promise.prototype.finally()方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。不管promise最后的状态，在执行完then或catch指定的回调函数以后，都会执行finally方法指定的回调函数。finally本质上是then方法的特例。
    
    除了串行执行若干异步任务外，Promise还可以并行执行异步任务。试想一个页面聊天系统，我们需要从两个不同的URL分别获得用户的个人信息和好友列表，这两个任务是可以并行执行的，用Promise.all()实现如下：
    var p1 = new Promise(function (resolve, reject) {
        setTimeout(resolve, 500, 'P1');
    });
    var p2 = new Promise(function (resolve, reject) {
        setTimeout(resolve, 600, 'P2');
    });
    // 同时执行p1和p2，并在它们都完成后执行then:
    Promise.all([p1, p2]).then(function (results) {
        console.log(results); // 获得一个Array: ['P1', 'P2']
    });
    Promise.all()接受一个promise对象对象的数组，待所有实例对象变成fulfilled之后，p1、p2、p3的返回值组成一个数组，传递给p的回调函数。只要有一个被rejected，第一个被reject的实例返回值会传给p的回调函数。
    
    Async/Await：它就是 Generator 函数的语法糖，函数前面多了一个aync关键字，await关键字只能用在aync定义的函数内。async函数会隐式地返回一个promise，该promise的reosolve值就是函数return的值。
    优点：
    （1）简洁，不需要写.then，不需要写匿名函数处理Promise的resolve值，也不需要定义多余的data变量，还避免了嵌套代码。
    （2）Async/Await让try/catch可以同时处理同步和异步错误。
    
    
    ```

    

11. 说一下 **Vue 双向绑定**的原理？详细说一下；设计模式是什么？

    

12. 说一下你对**虚拟 DOM** 的理解？怎么知道某个结构需要渲染更新？（设置标签？）

    

13. Vue 的**路由**有哪些方式？具体实现，依赖什么 API ？

    ```
    hash: 在浏览器中符号“#”，#以及#后面的字符称之为hash，用window.location.hash读取。特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面，支持所有浏览器。
    
    history : 依赖HTML5 History API和服务器配置。提供了两个新方法：pushState()，replaceState()可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。history模式下，前端的 URL 必须和实际向后端发起请求的URL一致.
    ```

    

14. 简历上的项目都是你自己开发的吗？还是有合作的同学一起？

15. 项目上你有遇到过什么问题吗？是怎么解决的？

16. **反问环节**
    准备几个反问的问题：



## **存在的问题：**

1. 首先是对于基本概念，还要熟悉，多理解记忆。
2. 回答问题的时候**语速比较慢**，有些没有意义的词，比如“这个”，“那个”，“额”，“就是……”，“然后”。
3. 自己项目方面的东西，无关前端的也可以做一些**拓展**，不需要太深入。
4. 项目上**遇到的问题**，需要回顾总结一下，还不知道如何回答。
5. **反问环节**的问题提前准备好。

屡败屡战，继续努力吧。💻

