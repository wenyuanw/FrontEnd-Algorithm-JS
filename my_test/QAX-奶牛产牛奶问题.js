/*
 * @Author: Ran
 * @Date: 2021-03-06 18:18:26
 * @LastEditors: Ran
 * @LastEditTime: 2021-03-06 20:54:16
 * @FilePath: \JZoffer\QAX-奶牛产牛奶问题.js
 * @Description: 
 * --------20210306奇安信笔试--------
 * 小明打算建一个奶牛场来生产牛奶，要从一群奶牛中挑选，
 * 每只奶牛每天会吃 x 捆草，产出 y 桶牛奶。
 * 如果一个奶牛场里吃草较多的奶牛产出的奶小于吃草较少的奶牛，
 * 那么这两头奶牛会经常打架，吃草相同的奶牛之间不会打架，产奶
 * 相同的奶牛之间也不会打架。
 * 现在从一群奶牛中挑选奶牛，小明同学希望挑选出来的奶牛
 * 1、之间不能打架，2、产出的总牛奶量最大。
 * 请你为小明计算满足这两个条件所选出的奶牛每天能产出的牛奶桶数。
 * 
 * 示例 1：
 * 输入：
 * [2, 3, 4, 5, 6], [2, 4, 7, 9, 12]
 * 输出：
 * 34
 * 
 * 这群奶牛每天吃的草的捆数依次是2, 3, 4, 5, 6
 * 产出的牛奶桶数依次是2, 4, 7, 9, 12
 * 选出的奶牛是所有5头奶牛，
 * 产出的牛奶桶数是34。
 * 示例 2:
 * 输入：
 * [3, 5, 8, 2], [2, 3, 5, 7]
 * 输出：
 * 10
 * 
 * 这群奶牛每天吃的草的捆数依次是3, 5, 8, 2
 * 产出的牛奶桶数依次是2, 3, 5, 7
 * 选出的奶牛是前3头奶牛，
 * 产出的牛奶桶数是10。
 * 
 */

let grase = [2, 2, 2, 2, 2];
let milk = [1, 1, 1, 1, 12];
let milk_sum = 0;
// 暴力解法，遍历数组次数太多，存在太多重复计算
function MaxMilk(grase, milk) {
    for (let i = 0; i < grase.length; i++) {
        let temp = 0;
        for (let j = 0; j < grase.length; j++) {
            if (i != j && grase[i] > grase[j] && milk[i] < milk[j]) {
                // 打架的情况
            } else if (i != j && grase[i] < grase[j] && milk[i] > milk[j]) {
                // 打架的情况
            } else {
                // 跟grase[i]所对应的牛不打架则累加
                temp += milk[j];
            }
        }
        if (temp > milk_sum)
            milk_sum = temp;
    }
    return milk_sum;
}
console.log(MaxMilk(grase, milk));

// == 看牛客有说用回溯的，有说用动态规划的。